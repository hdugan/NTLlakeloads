---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  message = FALSE
)
```

## Why?
A better way of interpolating nutrient data in the lakes. Both for load calculations and for data visualization. 

We often linearly interpolate water quality observations between observation depths. This is typically fine if a lake is well mixed, but if it's stratified it introduces a lot of error around the thermocline. Here, I provide functions to interpolate water quality observations leveraging information on lake stratification from temperature data. Often there is more temperature data than water quality data, which results in better interpolation. 

## Installation
You can install NTLlakeloads from github using devtools:

```{r gh-installation, eval = F}
install.packages("devtools")
devtools::install_github("hdugan/NTLlakeloads")
library(NTLlakeloads)
```

```{r library, include = F}
library(NTLlakeloads)
```

## Get LTER data
```{r getLTERdata, eval = T, warning = F, message = F}
# Load NTL datasets
LTERtemp = loadLTERtemp() # Download NTL LTER data from EDI
LTERnutrients = loadLTERnutrients() # Download NTL LTER data from EDI
LTERions = loadLTERions() # Download NTL LTER data from EDI
LTERsecchi = loadLTERsecchi() # Download NTL LTER data from EDI
```

## Variables available for plotting
```{r, eval = FALSE}
# Available variables
availableVars()

# Available variables that are not depth-discrete. Used with weeklyInterpolate.1D.
availableVars.1D()
```

## Interpolate weekly total phosphorus data for Lake Mendota
```{r, eval = T, warning = F, message = F, results = 'hide'}
# printFigs = TRUE to output series of interpolated profiles (but slower)
# See help file for parameter descripts
df.ME = weeklyInterpolate(lakeAbr = 'ME', var = 'totpuf_sloh', dataset = LTERnutrients, maxdepth = 24, 
                          constrainMethod = 'zero', setThreshold = 0.1, printFigs = F)
```

## Plotting entire timeseries 
```{r, eval = T, warning = F, message = F, fig.width = 7}
plotTimeseries(df.ME$weeklyInterpolated, var = 'totpuf_sloh')
```

## Plot specific year with observed data
```{r, eval = T, warning = F, message = F, fig.width = 7 }
# With observations
plotTimeseries.year(df.interpolated = df.ME$weeklyInterpolated, observations = df.ME$observations,  var = 'totpuf_sloh', chooseYear = 2008)
# Without observations, but adding legend title 
plotTimeseries.year(df.interpolated = df.ME$weeklyInterpolated, var = 'totpuf_sloh', chooseYear = 2008, legend.title = 'TP (Âµg/L)')
```

## Calculate load at annual or weekly timescales
```{r, eval = T, results = 'hide', warning = F, message = F}
df.load.annual = calcLoad(df.ME$weeklyInterpolated,lakeAbr = 'ME', time.res = 'annual', conversion = 1e6)
```

## Example of plotting annual load 
```{r, eval = T, warning = F, message = F, fig.width = 7, fig.height= 4}
ggplot(df.load.annual, aes(x = year, y = load)) +
  geom_path() +
  geom_point() +
  ylab('TP (kg)') +
  labs(title = 'Lake Mendota annual TP load', caption = 'Calculated from NTLlakeloads') +  
  theme_bw(base_size = 10) +
  theme(axis.title.x = element_blank())
```

## Decompose timeseries to analyse trends, seasonality
```{r, eval = T, warning = F, message = F}
decomposeTS(df.load, lakeAbr = 'ME', var = 'totpuf_sloh')
```
